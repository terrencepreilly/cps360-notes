Von Neumann Architecture
    When we execute a program under Von Neumann Architecture the following
    steps happen:
        1) fetch the program from the destination and load into memory
        2) point to the first instruction
        3) set the program counter to the first instruction

// File try.c
// compile with:
//      gcc try.c -o try
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    int x = 0xabc;
    printf("%d\n", x);
    exit(0); // Do not use return
}

OS --> Assembly --> Machine Language --> Circuits --> Logic Gates -|-> Physics

When the compiler instantiates an array of a given type, the address of the
array is divisible by the sizeof( the type ).

struct node {
    int info;
    struct node *next;
};
typedef struct node node;

int main(void) {
    node a1, a3;
    a1.info = 123;
    a1.next = NULL;
    a3 = &a1; // a3->info == a1.info
}

Addresses are four bytes (in a four byte system.)

The memory for a system:
    +-------+
    | text  |
    +-------+
    | data  | -- where the memory for dynamic allocation comes from.
    +-------+
    | heap  |
    +-------+
    | stack |
    +-------+

void getnode(node **p) {
        *p = malloc(sizeof(node));
}

void caller() {
    void getnode(int **); // only declare functions where you need them.
    node *ptr;
    getnode(&ptr);
    if (!ptr) {  // or ptr == NULL
        // error
    }
}

void search(node *list, int *i, node **pred, node **cont) {
    *cont = list;
    *pred = NULL;
    while (*cont) {
        if ((*cont)->info == x;)
            return;
        *cont = *(cont)->next;
        *pred = *cont;
    }
}

Inside of the department, cps158.  Sparc64 Look this up.
You should be able to use the editor.  HLearn the c debugger the makefile is 
contained in /tmp.

multics -- Bell labs by the creator of unix.  To make this they designed C. (1972).  C is a procedural language in the family with ALGOL.  It is compiled, procedural.  (a procedural is the same as a module.)  
    By default char is not signed.  -128 < < 127.  float is a single point floating int.  Double is double precision.  Functions define "your defined instruction."  Formal parameter is the parameter type in a function prototype.  (functions occurr three times.)  Activation record is the name of the brake of memory in the stack.  Everything is added to the stack. (Including the local variables.  Where is the heap?)

        char 256
        int 4 bytes
            2 bytes (short)
            8 bytes (long)
            16 bytes (long long)
        float 32 bits
        double 64 bits
        extended precision 90 bits
        quad precision 128 bits.

    int a = 3, b = 5, *z; add(a, b, z); // seg fault (holds garbage.)
    int **x; -\
               \        |       |
                \-----> +-------+
                        |       | x
                        +--^----+
                        |  |    | *x
                        +--^----+
                        |  |    | **x
                        +-------+
                        |       |

    try swaping two values without using a temporary variable.

precision is baped in the significand.  So single precision has 23 bit-precision

For floating point integers we have a normalized significand (which means that
the digits to the right of the decimal must be non zero.)  THis is to guard against multiple representations such as 0.5*10e0 = 0.05*10e1. Because the digit is
always one, then, we do not need to remember it.  Single precision (32 bits),
double precision (64 bits).  And extended precision (80 bits).  (Intel.)  Quad
precision (128 bits -- non-standard.)

Single:
 sign
  |  biased
  V  exponent   normalized significand
 +-----------------------------------+
 | |         |                       |
 +-----------------------------------+
1 bit 8 bits    23 bits

Converting a decimal
    Convert 0.5:
        0.5 x 2 = 1.0

        0.5 (decimal) --> 0.1 (binary)

    Convert 23.5 (decimal) to binary
    23 --> 10111.1 == 1.01111*2e4  add bias 127 --> 1.01111*e(127+4)
       --> 0 10000011 01111000000000000000000
       --> 0x413C0000

    Convert 0.33333:
        0.33333 * 2 = 0.66666
        0.66666 * 2 = 1.33332
        0.33332 * 2 = 0.66664
        0.66664 * 2 = 1.33328
        0.33328 * 2 = 0.66658
        0.66658 * 2 = 1.33312

        0.33333... (decimal) --> 0.010101... (binary)


Double precision:

    sign
     | biased
     V exponent      normalized significand
    +-------------------------------------------------------------------+
    | |          |                                                      |
    +-------------------------------------------------------------------+
     1  11             52

3.75 (decimal) --> 11.11 == 1.111*2e1 == 1.111*2e(1083+1)
0 10000001110 1110000000000000000000000000000000000000000000000000

Extended precision has extra bits in the significant.

Quad precision: 1 sign bit, 15 exponent bits, 110 significand bits
For Intel processors, the remaining bits are truncated to 64 bits by the OS.

Shapes
    ASCII code 7 bits.  Was folowed by UTF (Universal Text format), which has several formats: 8, 16, 32.  Unicode is a standard which does not say how to represent the characters.  Windows uses UTF16LE for unicode representation.  (Unicode is a standard, not an encoding scheme.)  ASCII shapes fit the same representation of contiguous intres.

George Boole (1856) - described multivalued discrete Algebra.
Huntington (1904) - imposed the condition that variables should be either 0 or 1.  He wrote the axiom of this algebra.
Shanon (1936) - used Huntington's math to design relays.

    http://theory.stanford.edu/~aiken/moss

Simplification of logic gates is done with either algebraic simplification or Karnaugh maps.

    ex: F(x, y) = xy + x'y + xy' + x'y'
                = y(x + x') + y'(x + x')
                = y + y'
                = 1

Karnaugh maps (kmaps) -- relies on the sasumption that we should be able to
express a boolean function as a sum of main terms (produces the maximum number
of main terms is determined by 2^n where n is the number of variables.) 2, 3,
4, etc. variable k-maps.

2 Variable k-map

  x\y 0    1
    +----+----+      +----+----+
  0 | 0  | 1  |      |x'y'|x'y |
    +----+----+ <==> +----+----+
  1 | 2  | 3  |      |xy' | xy |
    +----+----+      +----+----+

3 Variable k-map
  x\yz 00  01   11   10
    +----+----+----+----+
  0 |    |    |    |    |
    +----+----+----+----+
  1 |    |    |    |    |
    +----+----+----+----+

    NB. Adjacent entries can only differ by 1 bit. (Gray code)

Ex:
    F(x, y) = xy' + xy

        First we convert F as a sum of main terms:

    F(x, y) = \Sigma (2, 3)

        Then we mark the boxes for those main terms with ones

  x\y 0    1       x\y  0   1
    +----+----+      +----+----+
  0 | 0  | 1  |    0 |  0 | 0  |
    +----+----+ ===> +----+----+
  1 | 2  | 3  |    1 |  1 | 1  |
    +----+----+      +----+----+

        Then we find the largest cover of main terms.  Here, there is a
        cover of two.  we remove those terms which change in the cover.
        in this case, we remove the y term because it goes from 0 to 1
        inside of the cover of two.  x retains its value, and so we keep
        it:
    F(x, y) = x

Covers always go in multiples of 2.  Remove the terms which change in the cover.
A term can be shared between covers, but covers cannot be nested.
    Ex:
      x\y  0    1
        +----+----+
      0 |  0 |  1 |
        +----+----+
      1 |  1 |  1 |
        +----+----+

    In this k-map, there are two covers of two, sharing the 1-bit in
    the three box (The y term.)


     x      ____
    -----|-|    \   (x'y) + (xy')
     y   | |     }---------
    -----|-|____/

4-variable k-maps
    F(w, x, y, z) = ...

     F
      \yz
     wx\  00   01   11   10
        +----+----+----+----+
     00 | 0  | 1  | 3  | 2  |
        +----+----+----+----+
     01 | 4  | 5  | 7  | 6  |
        +----+----+----+----+
     11 | 12 | 13 | 15 | 14 |
        +----+----+----+----+
     10 | 8  | 9  | 11 | 10 |
        +----+----+----+----+

Number of midterms -- a midterm is a combination of statements
that perfectly describes a single row in the truth table.

Having covers of four, etc., you can bend it so that all four corners touch.
There is no way to see having functions is minimalized.  All processes are
optimized for adding use adders.

Ex:
    Build a circuit for a half-adder

    1) Construct a truth-table

        x  | y  | Sum | Carry
        ---|----|-----|------
        0  | 0  | 0   | 0
        0  | 1  | 1   | 0
        1  | 0  | 1   | 0
        1  | 1  | 0   | 1

    2) Determine the midterms for Sum and Carry
        S(x, y) = x'y + xy'
        C(x, y) = xy

    3) Minimize the number of terms, if possible
          S
          x\y 0     1
            +----+----+
          0 | 0  | 1  |
            +----+----+
          1 | 1  | 0  |
            +----+----+
      There are two covers of one, so it cannot be further optimized.  Carry
      has only one term, and so it cannot be optimized, either.

      So,
            S(x, y) = x XOR y
            O(x, y) = xy

    4) Build logic diagram

     x         ____
    -----+--|-|    \   Sum
     y   |  | | XOR }---------
    ---+-|--|-|____/
       | |
       | |    ____
       | +----|   \    Carry
       |      |AND |---------
       +------|___/



To implement a full-adder you have to use the carry from a half-adder.

    1) Build the truth table

        i  | x  | y  | S  | O
        ----------------------
        0  | 0  | 0  | 0  | 0
        0  | 0  | 1  | 1  | 0
        0  | 1  | 0  | 1  | 0
        0  | 1  | 1  | 0  | 1
        1  | 0  | 0  | 1  | 0
        1  | 0  | 1  | 0  | 1
        1  | 1  | 0  | 0  | 1
        1  | 1  | 1  | 1  | 1

        Here, i is carry in, O is carry out

    2) Represent as a function of minterms

        S(ci, x, y) = i'x'y + i'xy' + ix'y' + ixy
        O(ci, x, y) = i'xy +ix'y + ixy' + ixy

    3) Try to minimize
          S
          i\xy 00  01   11   10
            +----+----+----+----+
          0 | 0  | 1  | 0  | 1  |
            +----+----+----+----+
          1 | 1  | 0  | 1  | 0  |
            +----+----+----+----+

          O
          i\xy 00  01   11   10
            +----+----+----+----+
          0 | 0  | 0  | 1  | 0  |
            +----+----+----+----+
          1 | 0  | 1  | 1  | 1  |
            +----+----+----+----+

        We can notice that the pattern in S is that of an XOR, that is,
            S(i, x, y) = i XOR x XOR y.
        Which is very similar to the half-adder.

        O has three covers of two:
            O(i, x, y) = xy + iy + ix
        O is also very similar to the half-adder.

    4) Build the logic diagram

        x          ___
        -----+--|-|   \
        y    |  | |XOR }---+      ___
        --+--|--|-|___/    +-+--|-|   \
        i |  |               |  | |XOR }--------------------
        --|--|-----------+---|--|-|___/
          |  |           |   |     ___
          |  |           |   +----|   \
          |  |           |        |AND |----+     ____
          |  |           +--------|___/      +----\   \
          |  |                     __              |OR }----
          |  +--------------------|   \      +----/___/
          |                       |AND |----+
          +-----------------------|___/


Full adders are generally equipped with an enable.  They can be chained
together to create a ripple-carry adder:
            x1  y1       x2  y2
           _|___|_       _|___|_
     c2   |  FA   |  c1 |  FA   |
     <----|_______|<----|_______|<----Co
              |             |
              s1            s0
Ripple-carry adders have a significant disadvantage: each full-adder in the
chain cannot be evaluated until it receives the carry out from the full-adder
before it.  However, we can implement an adder in  constant time by separating
the carry and sum bits into two operations.  There will be a carry for
c1 + 1 = aibi + aici + bici = aibi + ci(ai + bi).  This is called a carry
generate property adder.

Parity bit -- add a parity bit and dictat that the number of bits should be always
even (even parity) or odd (odd parity).

Ex: design a circuit to calculate an odd parity bit for three bits.

    1) Build a truth table
        x  | y  | z  | p
        ---|----|----|--
        0  | 0  | 0  | 1
        0  | 0  | 1  | 0
        0  | 1  | 0  | 0
        0  | 1  | 1  | 1
        1  | 0  | 0  | 0
        1  | 0  | 1  | 1
        1  | 1  | 0  | 1
        1  | 1  | 1  | 0

    2) Represent as a function of min terms
        f(x, y, z) = x'y'z' + x'yz + xy'z + xyz'

    3) Try to minimize the expression

      f
      x\yz 00  01   11   10
        +----+----+----+----+
      0 |  1 |  0 |  1 | 0  |
        +----+----+----+----+
      1 |  0 |  1 |  0 | 1  |
        +----+----+----+----+

        There is again a checkerboard pattern. However, it is the inverse of
        the XOR operation.

        f(x, y, z) = (x XOR y XOR z)'

    4) Draw the diagram

        x         ___
        -------|-|   \
        y      | |XOR }---+      ___
        -------|-|___/    +---|-|   \
        z                     | |XOR }--- p
        ----------------------|-|___/


    ex:
        Generate an odd parity checker for four bits

        1)
            x  | y  | z  | p  | c
            ---|----|----|----|---
            0  | 0  | 0  | 0  | 1
            0  | 0  | 0  | 1  | 0
            0  | 0  | 1  | 0  | 0
            0  | 0  | 1  | 1  | 1
            0  | 1  | 0  | 0  | 0
            0  | 1  | 0  | 1  | 1
            0  | 1  | 1  | 0  | 1
            0  | 1  | 1  | 1  | 0
            1  | 0  | 0  | 0  | 0
            1  | 0  | 0  | 1  | 1
            1  | 0  | 1  | 0  | 1
            1  | 0  | 1  | 1  | 0
            1  | 1  | 0  | 0  | 1
            1  | 1  | 0  | 1  | 0
            1  | 1  | 1  | 0  | 0
            1  | 1  | 1  | 1  | 1
