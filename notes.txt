Von Neumann Architecture
    When we execute a program under Von Neumann Architecture the following
    steps happen:
        1) fetch the program from the destination and load into memory
        2) point to the first instruction
        3) set the program counter to the first instruction

// File try.c
// compile with:
//      gcc try.c -o try
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    int x = 0xabc;
    printf("%d\n", x);
    exit(0); // Do not use return
}

OS --> Assembly --> Machine Language --> Circuits --> Logic Gates -|-> Physics

When the compiler instantiates an array of a given type, the address of the
array is divisible by the sizeof( the type ).

struct node {
    int info;
    struct node *next;
};
typedef struct node node;

int main(void) {
    node a1, a3;
    a1.info = 123;
    a1.next = NULL;
    a3 = &a1; // a3->info == a1.info
}

Addresses are four bytes (in a four byte system.)

The memory for a system:
    +-------+
    | text  |
    +-------+
    | data  | -- where the memory for dynamic allocation comes from.
    +-------+
    | heap  |
    +-------+
    | stack |
    +-------+

void getnode(node **p) {
        *p = malloc(sizeof(node));
}

void caller() {
    void getnode(int **); // only declare functions where you need them.
    node *ptr;
    getnode(&ptr);
    if (!ptr) {  // or ptr == NULL
        // error
    }
}

void search(node *list, int *i, node **pred, node **cont) {
    *cont = list;
    *pred = NULL;
    while (*cont) {
        if ((*cont)->info == x;)
            return;
        *cont = *(cont)->next;
        *pred = *cont;
    }
}

Inside of the department, cps158.  Sparc64 Look this up.
You should be able to use the editor.  HLearn the c debugger the makefile is 
contained in /tmp.

multics -- Bell labs by the creator of unix.  To make this they designed C. (1972).  C is a procedural language in the family with ALGOL.  It is compiled, procedural.  (a procedural is the same as a module.)  
    By default char is not signed.  -128 < < 127.  float is a single point floating int.  Double is double precision.  Functions define "your defined instruction."  Formal parameter is the parameter type in a function prototype.  (functions occurr three times.)  Activation record is the name of the brake of memory in the stack.  Everything is added to the stack. (Including the local variables.  Where is the heap?)

        char 256
        int 4 bytes
            2 bytes (short)
            8 bytes (long)
            16 bytes (long long)
        float 32 bits
        double 64 bits
        extended precision 90 bits
        quad precision 128 bits.

    int a = 3, b = 5, *z; add(a, b, z); // seg fault (holds garbage.)
    int **x; -\
               \        |       |
                \-----> +-------+
                        |       | x
                        +--^----+
                        |  |    | *x
                        +--^----+
                        |  |    | **x
                        +-------+
                        |       |

    try swaping two values without using a temporary variable.

precision is baped in the significand.  So single precision has 23 bit-precision

For floating point integers we have a normalized significand (which means that
the digits to the right of the decimal must be non zero.)  THis is to guard against multiple representations such as 0.5*10e0 = 0.05*10e1. Because the digit is
always one, then, we do not need to remember it.  Single precision (32 bits),
double precision (64 bits).  And extended precision (80 bits).  (Intel.)  Quad
precision (128 bits -- non-standard.)

Single:
 sign
  |  biased
  V  exponent   normalized significand
 +-----------------------------------+
 | |         |                       |
 +-----------------------------------+
1 bit 8 bits    23 bits

Converting a decimal
    Convert 0.5:
        0.5 x 2 = 1.0

        0.5 (decimal) --> 0.1 (binary)

    Convert 23.5 (decimal) to binary
    23 --> 10111.1 == 1.01111*2e4  add bias 127 --> 1.01111*e(127+4)
       --> 0 10000011 01111000000000000000000
       --> 0x413C0000

    Convert 0.33333:
        0.33333 * 2 = 0.66666
        0.66666 * 2 = 1.33332
        0.33332 * 2 = 0.66664
        0.66664 * 2 = 1.33328
        0.33328 * 2 = 0.66658
        0.66658 * 2 = 1.33312

        0.33333... (decimal) --> 0.010101... (binary)


Double precision:

    sign
     | biased
     V exponent      normalized significand
    +-------------------------------------------------------------------+
    | |          |                                                      |
    +-------------------------------------------------------------------+
     1  11             52

3.75 (decimal) --> 11.11 == 1.111*2e1 == 1.111*2e(1083+1)
0 10000001110 1110000000000000000000000000000000000000000000000000

Extended precision has extra bits in the significant.

Quad precision: 1 sign bit, 15 exponent bits, 110 significand bits
For Intel processors, the remaining bits are truncated to 64 bits by the OS.

Shapes
    ASCII code 7 bits.  Was folowed by UTF (Universal Text format), which has several formats: 8, 16, 32.  Unicode is a standard which does not say how to represent the characters.  Windows uses UTF16LE for unicode representation.  (Unicode is a standard, not an encoding scheme.)  ASCII shapes fit the same representation of contiguous intres.

George Boole (1856) - described multivalued discrete Algebra.
Huntington (1904) - imposed the condition that variables should be either 0 or 1.  He wrote the axiom of this algebra.
Shanon (1936) - used Huntington's math to design relays.

    http://theory.stanford.edu/~aiken/moss

Simplification of logic gates is done with either algebraic simplification or Karnaugh maps.

    ex: F(x, y) = xy + x'y + xy' + x'y'
                = y(x + x') + y'(x + x')
                = y + y'
                = 1

Karnaugh maps (kmaps) -- relies on the sasumption that we should be able to
express a boolean function as a sum of main terms (produces the maximum number
of main terms is determined by 2^n where n is the number of variables.) 2, 3,
4, etc. variable k-maps.

2 Variable k-map

  x\y 0    1
    +----+----+      +----+----+
  0 | 0  | 1  |      |x'y'|x'y |
    +----+----+ <==> +----+----+
  1 | 2  | 3  |      |xy' | xy |
    +----+----+      +----+----+

3 Variable k-map
  x\yz 00  01   11   10
    +----+----+----+----+
  0 |    |    |    |    |
    +----+----+----+----+
  1 |    |    |    |    |
    +----+----+----+----+

    NB. Adjacent entries can only differ by 1 bit. (Gray code)

Ex:
    F(x, y) = xy' + xy

        First we convert F as a sum of main terms:

    F(x, y) = \Sigma (2, 3)

        Then we mark the boxes for those main terms with ones

  x\y 0    1       x\y  0   1
    +----+----+      +----+----+
  0 | 0  | 1  |    0 |  0 | 0  |
    +----+----+ ===> +----+----+
  1 | 2  | 3  |    1 |  1 | 1  |
    +----+----+      +----+----+

        Then we find the largest cover of main terms.  Here, there is a
        cover of two.  we remove those terms which change in the cover.
        in this case, we remove the y term because it goes from 0 to 1
        inside of the cover of two.  x retains its value, and so we keep
        it:
    F(x, y) = x

Covers always go in multiples of 2.  Remove the terms which change in the cover.
A term can be shared between covers, but covers cannot be nested.
    Ex:
      x\y  0    1
        +----+----+
      0 |  0 |  1 |
        +----+----+
      1 |  1 |  1 |
        +----+----+

    In this k-map, there are two covers of two, sharing the 1-bit in
    the three box (The y term.)


     x      ____
    -----|-|    \   (x'y) + (xy')
     y   | |     }---------
    -----|-|____/

4-variable k-maps
    F(w, x, y, z) = ...

     F
      \yz
     wx\  00   01   11   10
        +----+----+----+----+
     00 | 0  | 1  | 3  | 2  |
        +----+----+----+----+
     01 | 4  | 5  | 7  | 6  |
        +----+----+----+----+
     11 | 12 | 13 | 15 | 14 |
        +----+----+----+----+
     10 | 8  | 9  | 11 | 10 |
        +----+----+----+----+

Number of midterms -- a midterm is a combination of statements
that perfectly describes a single row in the truth table.

Having covers of four, etc., you can bend it so that all four corners touch.
There is no way to see having functions is minimalized.  All processes are
optimized for adding use adders.

Ex:
    Build a circuit for a half-adder

    1) Construct a truth-table

        x  | y  | Sum | Carry
        ---|----|-----|------
        0  | 0  | 0   | 0
        0  | 1  | 1   | 0
        1  | 0  | 1   | 0
        1  | 1  | 0   | 1

    2) Determine the midterms for Sum and Carry
        S(x, y) = x'y + xy'
        C(x, y) = xy

    3) Minimize the number of terms, if possible
          S
          x\y 0     1
            +----+----+
          0 | 0  | 1  |
            +----+----+
          1 | 1  | 0  |
            +----+----+
      There are two covers of one, so it cannot be further optimized.  Carry
      has only one term, and so it cannot be optimized, either.

      So,
            S(x, y) = x XOR y
            O(x, y) = xy

    4) Build logic diagram

     x         ____
    -----+--|-|    \   Sum
     y   |  | | XOR }---------
    ---+-|--|-|____/
       | |
       | |    ____
       | +----|   \    Carry
       |      |AND |---------
       +------|___/



To implement a full-adder you have to use the carry from a half-adder.

    1) Build the truth table

        i  | x  | y  | S  | O
        ----------------------
        0  | 0  | 0  | 0  | 0
        0  | 0  | 1  | 1  | 0
        0  | 1  | 0  | 1  | 0
        0  | 1  | 1  | 0  | 1
        1  | 0  | 0  | 1  | 0
        1  | 0  | 1  | 0  | 1
        1  | 1  | 0  | 0  | 1
        1  | 1  | 1  | 1  | 1

        Here, i is carry in, O is carry out

    2) Represent as a function of minterms

        S(ci, x, y) = i'x'y + i'xy' + ix'y' + ixy
        O(ci, x, y) = i'xy +ix'y + ixy' + ixy

    3) Try to minimize
          S
          i\xy 00  01   11   10
            +----+----+----+----+
          0 | 0  | 1  | 0  | 1  |
            +----+----+----+----+
          1 | 1  | 0  | 1  | 0  |
            +----+----+----+----+

          O
          i\xy 00  01   11   10
            +----+----+----+----+
          0 | 0  | 0  | 1  | 0  |
            +----+----+----+----+
          1 | 0  | 1  | 1  | 1  |
            +----+----+----+----+

        We can notice that the pattern in S is that of an XOR, that is,
            S(i, x, y) = i XOR x XOR y.
        Which is very similar to the half-adder.

        O has three covers of two:
            O(i, x, y) = xy + iy + ix
        O is also very similar to the half-adder.

    4) Build the logic diagram

        x          ___
        -----+--|-|   \
        y    |  | |XOR }---+      ___
        --+--|--|-|___/    +-+--|-|   \
        i |  |               |  | |XOR }--------------------
        --|--|-----------+---|--|-|___/
          |  |           |   |     ___
          |  |           |   +----|   \
          |  |           |        |AND |----+     ____
          |  |           +--------|___/      +----\   \
          |  |                     __              |OR }----
          |  +--------------------|   \      +----/___/
          |                       |AND |----+
          +-----------------------|___/


Full adders are generally equipped with an enable.  They can be chained
together to create a ripple-carry adder:
            x1  y1       x2  y2
           _|___|_       _|___|_
     c2   |  FA   |  c1 |  FA   |
     <----|_______|<----|_______|<----Co
              |             |
              s1            s0
Ripple-carry adders have a significant disadvantage: each full-adder in the
chain cannot be evaluated until it receives the carry out from the full-adder
before it.  However, we can implement an adder in  constant time by separating
the carry and sum bits into two operations.  There will be a carry for
c1 + 1 = aibi + aici + bici = aibi + ci(ai + bi).  This is called a carry
generate property adder.

Parity bit -- add a parity bit and dictat that the number of bits should be always
even (even parity) or odd (odd parity).

Ex: design a circuit to calculate an odd parity bit for three bits.

    1) Build a truth table
        x  | y  | z  | p
        ---|----|----|--
        0  | 0  | 0  | 1
        0  | 0  | 1  | 0
        0  | 1  | 0  | 0
        0  | 1  | 1  | 1
        1  | 0  | 0  | 0
        1  | 0  | 1  | 1
        1  | 1  | 0  | 1
        1  | 1  | 1  | 0

    2) Represent as a function of min terms
        f(x, y, z) = x'y'z' + x'yz + xy'z + xyz'

    3) Try to minimize the expression

      f
      x\yz 00  01   11   10
        +----+----+----+----+
      0 |  1 |  0 |  1 | 0  |
        +----+----+----+----+
      1 |  0 |  1 |  0 | 1  |
        +----+----+----+----+

        There is again a checkerboard pattern. However, it is the inverse of
        the XOR operation.

        f(x, y, z) = (x XOR y XOR z)'

    4) Draw the diagram

        x         ___
        -------|-|   \
        y      | |XOR }---+      ___
        -------|-|___/    +---|-|   \    |\
        z                     | |XOR }---|!}O--p
        ----------------------|-|___/    |/


    ex:
        Generate an odd parity checker for four bits

        1)
            x  | y  | z  | p  | c
            ---|----|----|----|---
            0  | 0  | 0  | 0  | 1
            0  | 0  | 0  | 1  | 0
            0  | 0  | 1  | 0  | 0
            0  | 0  | 1  | 1  | 1
            0  | 1  | 0  | 0  | 0
            0  | 1  | 0  | 1  | 1
            0  | 1  | 1  | 0  | 1
            0  | 1  | 1  | 1  | 0
            1  | 0  | 0  | 0  | 0
            1  | 0  | 0  | 1  | 1
            1  | 0  | 1  | 0  | 1
            1  | 0  | 1  | 1  | 0
            1  | 1  | 0  | 0  | 1
            1  | 1  | 0  | 1  | 0
            1  | 1  | 1  | 0  | 0
            1  | 1  | 1  | 1  | 1

        2) f(x, y, z, p) = x'y'z'p' + x'y'zp + x'yz'p +
                           x'yzp' + xy'z'p + xy'zp' +
                           xyz'p' + xyzp

        3)
            xy\zp
               \  00   01   11   10
                +----+----+----+----+
             00 |  1 |  0 |  1 |  0 |
                +----+----+----+----+
             01 |  0 |  1 |  0 |  1 |
                +----+----+----+----+
             11 |  1 |  0 |  1 |  0 |
                +----+----+----+----+
             10 |  0 |  1 |  0 |  1 |
                +----+----+----+----+

            f(x, y, z, p) = (x XOR y XOR z XOR p)'

        4)         ____
            x ----|XOR |     ____
            y ----|____|----|XOR |     ____
            z---------------|____|----|XOR |
            p-------------------------|____|----|>o---c

        Checks for errors in computation (if its not even, or odd as we expect,
        then an error has occurred.)

4-bit adder
If we add the sign bit to this we have the magnitude (if it is positive,
we do not do anything.  If it is negative, we get the two's complement.)
             ___
       +--|-|   \
       |  | |XOR }---
    a0----|-|___/
       |
       |     ___
       +--|-|   \
       |  | |XOR }---
A   a1----|-|___/       A'
       |
       |     ___
       +--|-|   \
       |  | |XOR }---
    a2----|-|___/
       |
       |     ___
       |--|-|   \
       |  | |XOR }---
    a3-+--|-|___/

        (=) = x3 x2 x1 x0  where xi = aibi + ai'bi'
        (<) = b3a3' + x3b2a2' + x3x2b1a1' + x3x2x1b1a0'

    Magnitude comparator

        __|__|____|__|__
  c0 __|                |__ c1
       |________________|
           |   |   |
           >   =   <

Decoder -- allows you to select a particular numbered output

    2x4 decoder

    x  | y  | d0 | d1 | d2 | d3
    ---|----|----|----|----|----
    0  | 0  | 1  | 0  | 0  | 0
    0  | 1  | 0  | 1  | 0  | 0
    1  | 0  | 0  | 0  | 1  | 0
    1  | 1  | 0  | 0  | 0  | 1

void ha(int a, int b, int *s, int *s1) {
    *s = *c = 0;
    *s = (a & 1)^(b & 1);
    *c = (a & 1)&(b & 1);
}

ssh username@cps158.cps.cmich.edu
scp filename user@host:~/fileshere
scp user@host:~/filesthere filehere

2x4 Decoder
      ___
   a-|   |--ab
     |2x4|--ab'
   b-|   |--a'b
     |___|--a'b'

2x4 with enable 3x8 decoder
             ___
    a-----+-|   |--
          | |2x4|--
    b---+---|   |--
        | | |___|--
        | |   |
    e-+-------+
      | | |  ___
      | | +-|   |
      | |   |2x4|
      | +---|   |
      |     |___|
      V       |
      o ------+

Used to decode instructions:

    +--------+--------------+
    | opcode | operands     |
    +--------+--------------+

The opcode is the input and it selects the aperation to do.

Multiplexer -- (sharing of hardware.)  Selection tells if the output is to be.

        _____
        |    |
  I0----|2x1 |
        | mux|---- out
  I1----|    |
        |____|
          |
        selection


The following "function table" describes the above 2x1 multiplexer.

    selection  | I0 | I1 | out
    -----------|----|----|----
    0          | 0  | ...| 0
    0          | 1  | ...| 1
    1          | ...| 0  | 0
    1          | ...| 1  | 1

    Or, more simply

    s  | out
    ---|----
    0  | I0
    1  | I1


    I0                ___
    -----------------|   \
                +->o-|AND |---+
             +--|----|___/    |
             o  |             |    ___
             ^  |             +---\   \
    S        |  |                  |OR }--- O
    ---------+  |             +---/___/
             |  |     ___     |
             +--|----|   \    |
    I1          +->o-|AND |---+
    ------------|----|___/
                |
                e

dual inline 2x4 multiplexer -- made of 2 2x1 multiplexers.  To "multiplex the
process" is to use the mux to do multitasking.

         _______
        |  ___  |
    a0----|2x1| |
        | |mux|---o1
    a2----|___| |
        |  ___  |
    a1----|2x1| |
        | |mux|---o2
    a3----|___| |
        |_______|
            |
           Sel-----clock

Demultiplexer
             ___
            |   |---o1
       i----|   |
            |___|---o2


3x1 mux
           ___
    a0----|2x1|   ___
          |mux|--|2x1|
    a1----|___|  |mux|
    a2------|----|___|
            |      |
            s0     s1

    s0 | s1 | out
    ---|----|----
    0  | 0  | a0
    0  | 1  | a1
    1  | 0  | a2
    1  | 1  | a2

Sequential circuits (through time)  Uses a clock.  An oscillator
that generates equally spaced sequences of 0s and 1s.


    + ----| [] |--- -

         ____      ____      ____
        | 1  |    | 1  |    | 1  |
    ____|    |____|    |____|    |____
     0         0         0         0

    Once cycle is called a clock cycle.  The vertical bar represents
the rise time (the time it takes the oscillator to switch from 0 to
1.)
    Filtered to transpire from a signal like a sine wave.  One cycle
is called a "tick".  For every tick there is an interrupt.  Used in
time sharing, time-outs, and hardware use.  Combinational circuits do
remember anything.

    Time for NOT ( ->o )

        0   1   2   3   4   5   6
            ___         ___         1
  in 1         |_______|   |___     0

 out 1          _______     ___     1
            ___|       |___|        0


          ________________
    -----| Combinational  |-----
         |   Circuit      |
     +-->|________________|---+
     |         ___            |
     +--------[___]-----------+
              feedback
                mechanism

     We want out(t) = f( in( t-1 ) )

flip-flop/latch

    S/R latch (the base component of all flip-flops.)

    +----|>o--+------- 0
    |         |
    +------------+
              |  |      stable state
    +---------+  |
    |            |
    +----|>o-----+---- 1


Flip-flop with enable
         __             ___
        |   \          |   \
    +---|AND |---------|OR  }-+------- Q
    |   |___/       +--|___/  |
    |               |         |
e --|               +---------|-+
    |               +---------+ |
    |    ___        |   ___     |
    |   |   \       +--|   \    |
    +---|AND |---------|OR  }---+----- Q'
        |___/          |___/

Next state table
    R = 0   S = 0   (G2 = 0 G1 = 1)
    R = 0   S = 1v0 (G2 = 0 G1 = 1)
    R = 0^1 S = 0   (G2 = 1 G1 = 0)
    r = 1   s = 0^1 (G2 = 0 G1 = 0) -- invalid operation/state (Q1 and Q2 can't
                                       be the same.)

Next-state table
Q, Qn (next state)

    S  | R  | Qn                  S -- set input r -- reset input
    ---|----|--------------
    0  | 0  | no change (Q)
    0  | 1  | 0
    1  | 0  | 1
    1  | 1  | invalid

Next-state table for flipflop with enable

    e  | in1 | in2 |
    ---|-----|-----|---------
    0  |     |     | Q
    1  | 0   | 0   | Q
    1  | 0   | 1   | 0
    1  | 1   | 0   | 1
    1  | 1   | 1   | invalid

Excitation table
Given Q, Qn
What are the inputs to flip-flops like this?

    Q  | Qn | S  | R
    ---|----|----|---
    0  | 0  | 0  | x <-- don't care
    0  | 1  | 1  | 0
    1  | 0  | 0  | 1
    1  | 1  | x  | 0

     ___
in--|FF |--out
    |_ _|
      ^
      clock

The clock is tied to the enable (reflesh as in dynamic RAM)
To handle invalid inputs,

                Delay Flip-flop
                     ___
            R       |   \
        +-----------|OR  }o---+--- Q
        |        +--|___/     |
        |        |            |
        o        +----------+ |
        ^        +----------|-+
        |        |   ___    |
    D   |   S    +--|   \   |
    ----+-----------|OR  }o-+----- Q'
                    |___/

    D  | Qn
    ---|----
    0  | 0
    1  | 1

    There are also toggle flip-flops and JK flip-flops

state diagrame -- vertices (states) and edges (transitions).  1 is the input
0 is the output.
            0
     __   _____    ____
    /  \ L     \  L    \
  0|    Q       Q2      | 1
    \__7 \_____7  \____/
            1

SPARC
    mov, add, sub, srl, sll, sra, sla (sr shift right, sl is shift left.)
mov is a synthetic instruction made of

    add %g0, %l0, %l1

    Where %l0 is the destination, %l1 is the source

    add %l1, %l2, %l3 ! l1 is operand 1, l2 is operand 2, l3 is destination

    Condition codes: n z v c.  'n' is one if the result is negative, 'z' is one if the result is zero.  'v' is one if there is an overflow. Condition codes are only set if you use the cc version of opcodes such as addcc.  To compare two values there is a synthetic instruction:
    cmp %l0, %l1
    Which is composed of
    subcc %l0, %l1, %g0
    There are two ways to change the flow of the instruction: branch and jump. (branch is limited to the same function.)

    cmp %l2, 2
    be label         ! also bn, ba, bne
    nop              ! be is synthetic


ex:
        .data
    str:    .asciz "%x\n"
            .text
            .align 4

        .global main
    main: save %sp, -64, %sp ! reserves 64 bits on the stack
        mov 2, $o0           ! for the registers in the call frame
        mov 3, %o1
        call .mul
        nop

        mov %o0, %a1
        set str, %o1
        call printf
        nop

        clr %o0         ! This line is special for main
        call exit, 0    ! exit returns control back to the
        nop             ! operating system.

Instructions
    .rem    remainder
    .mul    multiply
    .div    divide
    are the synthetic instructions for this thing.
    To call a function (same for assembly and c)
        1) set the parameters in %o's.
        2) call the function.
        3) return is visible in %o0

        clr <==> add %g0 %g0 %o0

    when returning from function we say
        restore
        return
        nop

disassemble: disass or do it with gcc: gcc -S a1.c -o a1.s
    x/i derefference
    x/x the machine instruction
    x/x $ps

Register window (the register available to a caller.):

          | g
          | o
        -----
        g | l
        o | i
        -----
        l | B
        i |
        -----
        A |

    Register window A and B where A calls B.  When B terminates it sends the value
over.  The 64 comes from saving register l and i (g is shared and o becomes i.)
    save %sp, -64, %sp

call graph
                main

                  |
                  v

                  A

                  |
                  V

                  B

For each function the compiler sets up a call frame in the stack.  The information
that goes in a call frame is the return address to the caller.  It contains the
storage for local variables.  also, we store the parameters. When it happens that
we use to many function calls, we put the frame in the stack.  In the entire
processor there is only one window frame.  So parameters are passed in the stack.

                  g is shared throughout
                 /
              | g
              / o --> o becomes i (result returned in %o0)
             /----
          | g | l
          / o-->i
         /--------
        g / l | C
        o-->i |
        -------
        l | B
        i |
        ---
        A |



          |         |
   sp --> |         |
1)        | CF_main |
          |---------|



   sp --> |         |
          | CF_A    |
          |---------|
2)        | CF_main |
          |---------|



   sp --> |         |
          | CF_B    |
          |---------|
          | CF_A    |
          |---------|
3)        | CF_main |
          |---------|

 * fp points to the bottom of the current call frame.
   sp points to the top of the current call frame.

The frame pointer points to the bottom of the call frame.  The parameters are
below it in the calling function.  So a positive offset gets them.  The local
parameters are accessed with a negative offset.

Accessing memory. SPARC is a load-store architecture.  It loads a register from
memory (same as fetch.)  store stores the contents of the register to the memory.

    load [address] %d ! load th econtents of the memory at the location and puts it in d

    store %d [address] ! stores some data in memory

The load instructions are ldsb, ldub, ldsh, lduh, ld, ldd.  The store instructions
are stb, sth, st, std.  ld and st work with words (32 bits.)

    ex: ld [100], %l0 ! load 4 bytes into register from 100
    mov %l1, [100] ! moves those bytes into l1
    addrij = base iJ + j

You can map a multidimensional raray you can map it in two ways: row major and
column major.  Row major is mapped something like

    row1 | row2 | row3.

    C derivatives do this.  Fortran is column major:

    col1 | col2 | col3


Stack frame is composed of the following
    return address
    local variables
    parameters
    frame pointer
    saving registers

fp + n (parametres)
fp - n (locals)


A stack architecture works as follows

    push a           <==>  mov a, %i0
    push b                 mov b, %i1
    call mul               call .mul
                           nop

Control flow constructs use 2's complement

    if (x & 1)      <==>    ! x is %l0, odd is %l1
        odd = 1;            mov 1, %i1
    else                    and %l0, 1, %l2
        odd = 0;            cmp %l2, 1
                            bne else
                            nop
                            ba nelse
                            nop
                            else: mov 0, %l1
                            nelse:


    int sum(A[n]) {             <==>    clr %l2
        int i = 0, sum = 0;             clr %o0
        while (i < n) {                 loop: cmp %o0, %l1
            sum += A[i];                be done
            i++;                        nop
        }                               sll %o0, 2, %o3
        return sum;                     add %l0, %o3, %o3
    }                                   ld [%o3], %o1
                                        add %o1, %l2, %l2
                                        inc %o0
                                        ba loop
                                        nop
                                        done:


Accessing an array
    sll %o0, 2, %o3     ! multiply by 4 (offset)
    add %l0, %o3, %o3   ! o3 is the effective address
    ld [%o3], %o1


ISA (instruction set architecture) is made during the design of a new processor.
or when modifying or updating the current processor.  Involves arithmetic
operations, logic operations, controle flow (calling functions), accessing memory,
I/O, device access, recursion.  Return from subroutines.
        ____________
       | High Level |
       |  Language  |
       +------------+
       |    ISA     |
       +------------+
       |  Hardware  |
       |____________|

    Main features:
        1) Classification of ISA
            Defined by stack architecture (operands are implied.  Examples:
            HP_UX, calculators, JVM.)
        2) Accumulator register architecture.  There is a register called an
           accumulator which is involved in all operations. (One operand is in
           the accumulator, one is in the operand.)
                c <- a + b    <==>     load a
                                       add b
                                       store c
           Examples include the first processor 80s used in automatic doors and
           such.)
        3) Load and store architecture.
                load r1, [A]
                load r2, [B]
                add r1, r2, r3
                store [C], r3
           Examples include most modern processors.
        4) Memory acces and modes.  The ISA must address how the memory is
           addressed.  Memory is byte addressable or word addressable.  (This
           means that we can only acses words.)  It can be little endian or big
           big-endian.  Effective address -- the base address plus the offset.
           Memory modes: immediate (operand is in the instruction itself.
                ex: mov 2, %l2
           register mode (the operand is in the register.)
                ex: move %l1, %l2
           direct address mode (The memory address is directly in the operand.)
                ex: mov [100], %l3
           register direction (the address is in the register.
                ex: st %l0, [%l1]
           register indirection (address of the address of the operand is in
           the register (this is not supported in SPARC.)  To implement this we
           would
                mov 500, %l0
                ld [%l0], %l1
           reladive offset mode (uses effective addressing.)  The address is
           relative to some value.)  Relative to the program counter pc.  This is
           how branching and jumping work.  In the case of labels the address
           must by 24-bit 2's complement, so you can jump +/- 2^23.  since
           addresses are byte addressable, this is reduced to +/- 2^21 so it is
           pc +/- 2^21.

           load-point -- the start of a chunck of allocated memory.  So when a
           program is loaded it is loaded with the first instruction at the
           load point.  So compilers produce position independent code.
           (PIC)  This is code relative to the pc.

           index mode is relative mode where one register is the index register
           and addressing is relative to the contents of the indexregister.  This
           helpsfor accessing arrays.
                ex: load [%l0 + n], %l1 ! Where l0 is the index register
           Sparc does not have this.
           Autoincrement/autodecrement  this is the origin of ++. (Which now
           simulates autoincrement/autodecrement.)

goto in C is unconditional, while in assembly it is conditional.
ISA addressing modes: immediate, direct address register 9register indirect)
indirect relative indexed autoincrement, autodecrement.
    ex: 2 byte instruction size memory half-word adressable

    Type            Abbr    Contents
    Program counter pc      200
    Register        R1      400
    Index register  xR      100
    Accumulator     AC

    Memory:
        Address     Contents
        +------+------------------+
        | 200  |  load AC         |
        +------+------------------+
        | 201  |  500             |
        +------+------------------+
        | 202  |                  |
        +------+------------------+
        | ...  |                  |
        +------+------------------+
        | 399  |  450             |
        +------+------------------+
        | 400  |  700             |
        +------+------------------+
        | ...  |                  |
        +------+------------------+
        | 500  |  800             |
        +------+------------------+
        | ...  |                  |
        +------+------------------+
        | 600  |  900             |
        +------+------------------+
        | ...  |                  |
        +------+------------------+
        | 702  |  325             |
        +------+------------------+
        | ...  |                  |
        +------+------------------+
        | 800  |  300             |
        +------+------------------+


    Mode                AC      Effective Address
    direct address      800
    indirect address    300
    relative (pc)       325     EA = 500->202->702
    register            700
    index               900
    register indirect   700     EA = 400 (R1)
    immediate           500


    Sparc implementation.

        Immediate -- There is a size limitation of 13 bit two's complement
        (-4096 to 4095)
            mov 2, %l0
        Register
            mov %l0, %l1
        Relative (pc) -- The offset is 24-bit 2's complement, actually +/- 2^19
        because of the size of instructions and the sign byte.   This limits the
        size of a module to 8MB.
            ba iloop
            nop
        Indirect does not exist (we can simulate.)
        Direct addressing
            ld [100], %l1
        Indexed We can not do [%l0 + %l1] because it may be larger than 32 bits.
        This is how parameters are based is the call frame
            ld [%i0 + 100], %l1

        A -> B -> C ==> |       |                   ^   -
                        +-------+                   |
                        |  CF B |                   |
                        +-------+ <-- %fp           | lower
                        |  p B  | <-- %fp + 4       | addresses
                        +-------+                   |
                        |  CF A |                   |
                        +-------+                   |   +
        We need to use the frame pointer because the stack pointer is moving.
        A positive offset allows you to go to the previous call fram and the
        parameters.  Negative offsets allow you to go into the current call
        frame.  (No future.)

Other ISA operations: arithmetic logical flow control transfer (branch call and
return)  System call interface.


            
          ____________
         /Applications\
        /  __________  \
       /  / OS Kernel\  \
      /  /    ____    \  \
     /  /_   /    \   _\  \
    |   __  |  HW  |  __   |
     \  \    \____/    /  /
      \  \            /  /
       \  \___| |____/  /
        \              /
         \____________/

            the open gaps in the above representation are called "traps".
            They are implemented as system calls, and allow applications
            to access the underlying hardware.


System calls
    man 3 fread
    ex: exit
    In sparc you use a trap instruction, ta 0.  In the original unix there were
200 system calls.  In linux there are 600 system calls.  In Windows there are
close to 10,000 system calls.  System calls are possible back doors.
    System calls are stored in a system call table.
    To exit:

        clr %o0
        call exit, 0 ! actualy doing a ta 0
        nop

    Reading one byte at a time takes the same amount of overhead as reading 2048
bytes, say, from the system.  So we generally do buffered IO, because it is more
effective.

ISA count of operands.  Instruction format.  Options are fixed size (SPARC and
most risk processors), variable sized instructions (have gone out of fashion
sometimes known as mixed or hybrid.)  Classes of different instruction sizes
(byte word, double word, etc.) (This is technicaly known as fixed size within
classes.)  ISA symcode or instruction.
