VON NEUMANN ARCHITECTURE
COMPUTER STRUCTURE OVERVIEW
C LANGUAGE
    MEMORY
    ADDRESSES
    PRIMITIVE DATA TYPES IN C
    POINTERS
    FUNCTIONS
    EXAMPLES
FLOATING-POINT REPRESENTATION
SHAPES
BOOLEAN ALGEBRA
KARNAUGH MAPS
MINTERMS
BUILDING COMPONENTS
    HALF-ADDER
    FULL-ADDER
    RIPPLE-CARRY ADDER
    PARITY
    PARITY CHECKER
    4-BIT ADDER
    MAGNITUDE COMPARATOR
    DECODER
        2x4 DECODER
        3x8 DECODER
        MULTIPLEXER
        DUAL INLINE 2X4 MULTIPLEXER
        3x1 MULTIPLEXER
        DEMULTIPLEXER
TIMED CIRCUITS
    FLIP-FLOP
    NEXT-STATE TABLE
    EXCITATION TABLE
    DELAY FLIP-FLOP
    STATE DIAGRAM
SPARC ASSEMBLY
    CONDITION CODES
    INSTRUCTIONS
    GDB
    REGISTER WINDOW
BUILDING COMPONENTS
    CALL GRAPH
    WINDOW FRAME
    ACCESSING MEMORY
    STACK FRAME
    CONTROL FLOW
    ARRAYS
ISA
    MAIN FEATURES
    ADDRESSING MODES
        SPARC IMPLEMENTATION
    SYSTEM CALLS
    OPERAND ENCODING

------------------------------------------------------------------------------
VON NEUMANN ARCHITECTURE

         ______    store    __________
        /      \ --------> |          |
       |  CPU   |          |  memory  |
        \______/ <-------- |__________|
                   fetch

    When we execute a program under Von Neumann Architecture the following
    steps happen:
        1) fetch the program from the destination and load into memory
        2) point to the first instruction
        3) set the program counter to the first instruction


------------------------------------------------------------------------------
COMPUTER STRUCTURE OVERVIEW

    OS --> Assembly --> Machine Lang. --> Circuits --> Logic Gates -|-> Physics

    The above is a graph representing decreasing levels of abstraction.


------------------------------------------------------------------------------
C LANGUAGE
    The C language began with the operating system, Multix, created by
    Bell labs (the creators of Unix.)  To make the OS, they designed C.
    (1972).  C is a procedural language in the family with ALGOL.  It is
    compiled, procedural.  (A procedure is the same as a module.)

    MEMORY
        An activation record is the name of the brake of memory in the stack.
        Everything is added to the stack. (Including the local variables.)

        The memory for a system:
            +-------+
            | text  |
            +-------+
            | data  | -- where the memory for dynamic allocation comes from.
            +-------+
            | heap  |
            +-------+
            | stack |
            +-------+


    ADDRESSES
        Addresses are four bytes (in a four byte system.) When the compiler
        instantiates an array of a given type, the address of the array is
        divisible by the size of the type in bytes.

    PRIMITIVE DATA TYPES
        By default char is not signed.  Float is a single point
        floating number.  Double is double precision.

            char 256
            int 4 bytes
                2 bytes (short)
                8 bytes (long)
                16 bytes (long long)
            float 32 bits
            double 64 bits
            extended precision 90 bits
            quad precision 128 bits.

    POINTERS
        int a = 3, b = 5, *z; add(a, b, z); // seg fault (holds garbage.)

                            |       |
               int **x----> +-------+
                            |       | x
                            +--^----+
                            |  |    | *x
                            +--^----+
                            |  |    | **x
                            +-------+
                            |       |

        Try swaping two values without using a temporary variable.

    FUNCTIONS
         Formal parameter is the parameter type in a function prototype.

    EXAMPLES
        ex:
            // File try.c
            // compile with:
            //      gcc try.c -o try
            #include <stdio.h>
            #include <stdlib.h>

            int main(void) {
                int x = 0xabc;
                printf("%d\n", x);
                exit(0); // Do not use return
            }

        ex:
            struct node {
                int info;
                struct node *next;
            };
            typedef struct node node;

            int main(void) {
                node a1, a3;
                a1.info = 123;
                a1.next = NULL;
                a3 = &a1; // a3->info == a1.info
            }


        ex:

            void getnode(node **p) {
                    *p = malloc(sizeof(node));
            }

            void caller() {
                void getnode(int **); // use prototypes only where you need them.
                node *ptr;
                getnode(&ptr);
                if (!ptr) {  // or ptr == NULL
                    // error
                }
            }

            void search(node *list, int *i, node **pred, node **cont) {
                *cont = list;
                *pred = NULL;
                while (*cont) {
                    if ((*cont)->info == x;)
                        return;
                    *cont = *(cont)->next;
                    *pred = *cont;
                }
            }

------------------------------------------------------------------------------
FLOATING-POINT REPRESENTATION
    Precision is based on the significand.  So single precision has 23
    bit-precision.  Floating-point numbers come in the following precisions:
        Single precision (32 bits)
        Double precision (64 bits)
        Extended precision (80 bits)
        Quad precision (128 bits -- non-standard: only Intel)

    For floating point integers we have a normalized significand (which means
    that the digits to the right of the decimal must be non zero.)  This is to
    guard against multiple representations such as 0.5*10e0 = 0.05*10e1.
    Because the digit is always one, we do not need to remember it.

    Single:
     sign
      |  biased
      V  exponent   normalized significand
     +-----------------------------------+
     | |         |                       |
     +-----------------------------------+
    1 bit 8 bits    23 bits

    Converting a decimal
        Convert 0.5:
            0.5 x 2 = 1.0

            0.5 (decimal) --> 0.1 (binary)

        Convert 23.5 (decimal) to binary
        23 --> 10111.1 == 1.01111*2e4  add bias 127 --> 1.01111*e(127+4)
           --> 0 10000011 01111000000000000000000
           --> 0x413C0000

        Convert 0.33333:
            0.33333 * 2 = 0.66666
            0.66666 * 2 = 1.33332
            0.33332 * 2 = 0.66664
            0.66664 * 2 = 1.33328
            0.33328 * 2 = 0.66658
            0.66658 * 2 = 1.33312

            0.33333... (decimal) --> 0.010101... (binary)


    Double precision:

        sign
         | biased
         V exponent      normalized significand
        +-------------------------------------------------------------------+
        | |          |                                                      |
        +-------------------------------------------------------------------+
         1  11             52

        Ex:
            Convert 3.75 from decimal to double precision floating point binary.

            3.75 (decimal) --> 11.11 == 1.111*2e1 == 1.111*2e(1083+1)
            0 10000001110 1110000000000000000000000000000000000000000000000000

    Extended precision has extra bits in the significant.

    Quad precision: 1 sign bit, 15 exponent bits, 110 significand bits
    For Intel processors, the remaining bits are truncated to 64 bits by the OS.

------------------------------------------------------------------------------
SHAPES
    ASCII uses a 7-bit encoding scheme.  It was folowed by UTF (Universal Text
    Format), which has several formats: 8 bit, 16 bit, and 32 bit.  Unicode is a
    standard: it does not specify how to represent the characters.  Windows uses
    UTF16LE for unicode representation. ASCII encoding specifies that adjacent
    characters in the alphabet occupy adjacent places in the encoding scheme.
    (So, say, the position of "B" comes immediately before that of "C".)

------------------------------------------------------------------------------
    BOOLEAN ALGEBRA
    George Boole (1856) - described multivalued discrete Algebra.
    Huntington (1904) - imposed the condition that variables should be either
        0 or 1.  He wrote the axiom of this algebra.
    Shanon (1936) - used Huntington's math to design relays.

    Simplification of logic gates is done with either algebraic simplification
    or Karnaugh maps.

        ex:
            Simplify the following expression using boolean Algebra.
            F(x, y) = xy + x'y + xy' + x'y'
                    = y(x + x') + y'(x + x')
                    = y + y'
                    = 1

------------------------------------------------------------------------------
KARNAUGH MAPS
    Karnaugh maps (kmaps) -- rely on the assumption that we should be able to
    express a boolean function as a sum of midterms.  Karnaugh maps can be
    constructed for groups of two or more variables.

    2 VARIABLE K-MAP

      x\y 0    1
        +----+----+      +----+----+
      0 | 0  | 1  |      |x'y'|x'y |
        +----+----+ <==> +----+----+
      1 | 2  | 3  |      |xy' | xy |
        +----+----+      +----+----+


    3 VARIABLE K-MAP
      x\yz 00  01   11   10
        +----+----+----+----+
      0 | 0  | 1  | 3  | 2  |
        +----+----+----+----+
      1 | 4  | 5  | 7  | 6  |
        +----+----+----+----+

        NB. Adjacent entries can only differ by 1 bit. (Gray code)

    4-VARIABLE K-MAPS
        F(w, x, y, z) = ...

     F
      \yz
     wx\  00   01   11   10
        +----+----+----+----+
     00 | 0  | 1  | 3  | 2  |
        +----+----+----+----+
     01 | 4  | 5  | 7  | 6  |
        +----+----+----+----+
     11 | 12 | 13 | 15 | 14 |
        +----+----+----+----+
     10 | 8  | 9  | 11 | 10 |
        +----+----+----+----+

        NB. You can "bend" a table so that the coners touch.  Thus, in a
        4-variable k-map, if 0, 2, 8 and 10 are 1, you have a cover of four.

    Ex:
        F(x, y) = xy' + xy

            First we convert F as a sum of minterms:

        F(x, y) = \Sigma (2, 3)

            Then we mark the boxes for those minterms with ones

      x\y 0    1       x\y  0   1
        +----+----+      +----+----+
      0 | 0  | 1  |    0 |  0 | 0  |
        +----+----+ ===> +----+----+
      1 | 2  | 3  |    1 |  1 | 1  |
        +----+----+      +----+----+

            Then we find the largest cover of minterms.  Here, there is a
            cover of two.  we remove those terms which change in the cover.
            in this case, we remove the y term because it goes from 0 to 1
            inside of the cover of two.  x retains its value, and so we keep
            it:

        F(x, y) = x

    Covers always go in multiples of 2.  Remove the terms which change in
    the cover. A term can be shared between covers, but covers cannot be nested.
        Ex:
          x\y  0    1
            +----+----+
          0 |  0 |  1 |
            +----+----+
          1 |  1 |  1 |
            +----+----+

        In this k-map, there are two covers of two, sharing the 1-bit in
        the three box (The y term.)

------------------------------------------------------------------------------
MINTERMS

    Number of minterms -- a minterm is a combination of statements
    that perfectly describes a single row in the truth table.

------------------------------------------------------------------------------
BUILDING COMPONENTS

    HALF-ADDER
        Ex:
        Build a circuit for a half-adder

        1) Construct a truth-table

            x  | y  | Sum | Carry
            ---|----|-----|------
            0  | 0  | 0   | 0
            0  | 1  | 1   | 0
            1  | 0  | 1   | 0
            1  | 1  | 0   | 1

        2) Determine the minterms for Sum and Carry
            S(x, y) = x'y + xy'
            C(x, y) = xy

        3) Minimize the number of terms, if possible
              S
              x\y 0     1
                +----+----+
              0 | 0  | 1  |
                +----+----+
              1 | 1  | 0  |
                +----+----+

          There are two covers of one, so it cannot be further optimized.  Carry
          has only one term, and so it cannot be optimized, either.

          So,
                S(x, y) = x XOR y
                O(x, y) = xy

        4) Build logic diagram

         x         ____
        -----+--|-|    \   Sum
         y   |  | | XOR }---------
        ---+-|--|-|____/
           | |
           | |     ___
           | +----|   \    Carry
           |      |AND |---------
           +------|___/


        C implementation

            void ha(int a, int b, int *s, int *c) {
                *s = *c = 0;
                *s = (a & 1)^(b & 1);
                *c = (a & 1)&(b & 1);
            }



    FULL-ADDER
        To implement a full-adder you have to use the carry from a half-adder.

        1) Build the truth table

            i  | x  | y  | S  | O
            ----------------------
            0  | 0  | 0  | 0  | 0
            0  | 0  | 1  | 1  | 0
            0  | 1  | 0  | 1  | 0
            0  | 1  | 1  | 0  | 1
            1  | 0  | 0  | 1  | 0
            1  | 0  | 1  | 0  | 1
            1  | 1  | 0  | 0  | 1
            1  | 1  | 1  | 1  | 1

            Here, i is carry-in, O is carry-out

        2) Represent as a function of minterms

            S(ci, x, y) = i'x'y + i'xy' + ix'y' + ixy
            O(ci, x, y) = i'xy +ix'y + ixy' + ixy

        3) Try to minimize
              S
              i\xy 00  01   11   10
                +----+----+----+----+
              0 | 0  | 1  | 0  | 1  |
                +----+----+----+----+
              1 | 1  | 0  | 1  | 0  |
                +----+----+----+----+

              O
              i\xy 00  01   11   10
                +----+----+----+----+
              0 | 0  | 0  | 1  | 0  |
                +----+----+----+----+
              1 | 0  | 1  | 1  | 1  |
                +----+----+----+----+

            We can notice that the pattern in S is that of an XOR, that is,
                S(i, x, y) = i XOR x XOR y.
            Which is very similar to the half-adder.

            O has three covers of two:
                O(i, x, y) = xy + iy + ix
            O is also very similar to the half-adder.

        4) Build the logic diagram

            x          ___
            -----+--|-|   \
            y    |  | |XOR }---+      ___
            --+--|--|-|___/    +-+--|-|   \
            i |  |               |  | |XOR }--------------------
            --|--|-----------+---|--|-|___/
              |  |           |   |     ___
              |  |           |   +----|   \
              |  |           |        |AND |-----+    ____
              |  |           +--------|___/      +----\   \
              |  |                     __              |OR }----
              |  +--------------------|   \      +----/___/
              |                       |AND |-----+
              +-----------------------|___/

    RIPPLE-CARRY ADDER

        Full adders are generally equipped with an enable.  They can be chained
        together to create a ripple-carry adder:
                    x1  y1       x2  y2
                   _|___|_       _|___|_
             c2   |  FA   |  c1 |  FA   |
             <----|_______|<----|_______|<----Co
                      |             |
                      s1            s0
        Ripple-carry adders have a significant disadvantage: each full-adder
        in the chain cannot be evaluated until it receives the carry out
        from the full-adder before it.  However, we can implement an adder
        in  constant time by separating the carry and sum bits into two
        operations.  There will be a carry for
            c1 + 1 = aibi + aici + bici = aibi + ci(ai + bi).
        This is called a carry generate property adder.

    PARITY

        Parity bit -- add a parity bit and dictat that the number of bits
        should be always even (even parity) or odd (odd parity).

        Ex: design a circuit to calculate an odd parity bit for three bits.

            1) Build a truth table
                x  | y  | z  | p
                ---|----|----|--
                0  | 0  | 0  | 1
                0  | 0  | 1  | 0
                0  | 1  | 0  | 0
                0  | 1  | 1  | 1
                1  | 0  | 0  | 0
                1  | 0  | 1  | 1
                1  | 1  | 0  | 1
                1  | 1  | 1  | 0

            2) Represent as a function of min terms
                f(x, y, z) = x'y'z' + x'yz + xy'z + xyz'

            3) Try to minimize the expression

              f
              x\yz 00  01   11   10
                +----+----+----+----+
              0 |  1 |  0 |  1 | 0  |
                +----+----+----+----+
              1 |  0 |  1 |  0 | 1  |
                +----+----+----+----+

                There is again a checkerboard pattern. However, it is the
                inverse of the XOR operation.

                f(x, y, z) = (x XOR y XOR z)'

            4) Draw the diagram

                x         ___
                -------|-|   \
                y      | |XOR }---+      ___
                -------|-|___/    +---|-|   \
                z                     | |XOR }---|>o--p
                ----------------------|-|___/


    PARITY CHECKER
        ex:
        Generate an odd parity checker for four bits

        1)
            x  | y  | z  | p  | c
            ---|----|----|----|---
            0  | 0  | 0  | 0  | 1
            0  | 0  | 0  | 1  | 0
            0  | 0  | 1  | 0  | 0
            0  | 0  | 1  | 1  | 1
            0  | 1  | 0  | 0  | 0
            0  | 1  | 0  | 1  | 1
            0  | 1  | 1  | 0  | 1
            0  | 1  | 1  | 1  | 0
            1  | 0  | 0  | 0  | 0
            1  | 0  | 0  | 1  | 1
            1  | 0  | 1  | 0  | 1
            1  | 0  | 1  | 1  | 0
            1  | 1  | 0  | 0  | 1
            1  | 1  | 0  | 1  | 0
            1  | 1  | 1  | 0  | 0
            1  | 1  | 1  | 1  | 1

        2) f(x, y, z, p) = x'y'z'p' + x'y'zp + x'yz'p +
                           x'yzp' + xy'z'p + xy'zp' +
                           xyz'p' + xyzp

        3)
            xy\zp
               \  00   01   11   10
                +----+----+----+----+
             00 |  1 |  0 |  1 |  0 |
                +----+----+----+----+
             01 |  0 |  1 |  0 |  1 |
                +----+----+----+----+
             11 |  1 |  0 |  1 |  0 |
                +----+----+----+----+
             10 |  0 |  1 |  0 |  1 |
                +----+----+----+----+

            f(x, y, z, p) = (x XOR y XOR z XOR p)'

        4)         ____
            x ----|XOR |     ____
            y ----|____|----|XOR |     ____
            z---------------|____|----|XOR |
            p-------------------------|____|----|>o---c

        Checks for errors in computation (if its not even, or odd as we expect,
        then an error has occurred.)

    4-BIT ADDER
        4-bit adder
        If we add the sign bit to this we have the magnitude (if it is positive,
        we do not do anything.  If it is negative, we get the two's complement.)
                     ___
               +--|-|   \
               |  | |XOR }---
            a0----|-|___/
               |
               |     ___
               +--|-|   \
               |  | |XOR }---
        A   a1----|-|___/       A'
               |
               |     ___
               +--|-|   \
               |  | |XOR }---
            a2----|-|___/
               |
               |     ___
               |--|-|   \
               |  | |XOR }---
            a3-+--|-|___/

                (=) = x3 x2 x1 x0  where xi = aibi + ai'bi'
                (<) = b3a3' + x3b2a2' + x3x2b1a1' + x3x2x1b1a0'

    MAGNITUDE COMPARATOR

                __|__|____|__|__
          c0 __|                |__ c1
               |________________|
                   |   |   |
                   >   =   <

    DECODER
        Decoder -- allows you to select a particular numbered output.  Used
        to decode instructions:

            +--------+--------------+
            | opcode | operands     |
            +--------+--------------+

        The opcode is the input and it selects the aperation to do.

            2x4 decoder

            x  | y  | d0 | d1 | d2 | d3
            ---|----|----|----|----|----
            0  | 0  | 1  | 0  | 0  | 0
            0  | 1  | 0  | 1  | 0  | 0
            1  | 0  | 0  | 0  | 1  | 0
            1  | 1  | 0  | 0  | 0  | 1



        2x4 DECODER
                  ___
               a-|   |--ab
                 |2x4|--ab'
               b-|   |--a'b
                 |___|--a'b'

        3x8 DECODER

                         ___
                a-----+-|   |--
                      | |2x4|--
                b---+---|   |--
                    | | |___|--
                    | |   |
                e-+-------+
                  | | |  ___
                  | | +-|   |
                  | |   |2x4|
                  | +---|   |
                  |     |___|
                  V       |
                  o ------+

            Here, e is the enable


        MULTIPLEXER

            Multiplexer -- (sharing of hardware.)  Selection tells if the
            output is to be.

                     ____
                    |    |
              I0----|2x1 |
                    | mux|---- out
              I1----|    |
                    |____|
                      |
                    selection


            The following "function table" describes the above 2x1 multiplexer.

                selection  | I0 | I1 | out
                -----------|----|----|----
                0          | 0  | ...| 0
                0          | 1  | ...| 1
                1          | ...| 0  | 0
                1          | ...| 1  | 1

                Or, more simply

                s  | out
                ---|----
                0  | I0
                1  | I1


                I0                ___
                -----------------|   \
                            +->o-|AND |---+
                         +--|----|___/    |
                         o  |             |    ___
                         ^  |             +---\   \
                S        |  |                  |OR }--- O
                ---------+  |             +---/___/
                         |  |     ___     |
                         +--|----|   \    |
                I1          +->o-|AND |---+
                ------------|----|___/
                            |
                            e

        DUAL INLINE 2X4 MULTIPLEXER

            dual inline 2x4 multiplexer -- made of 2 2x1 multiplexers.
            To "multiplex the process" is to use the mux to do multitasking.

                     _______
                    |  ___  |
                a0----|2x1| |
                    | |mux|---o1
                a2----|___| |
                    |  ___  |
                a1----|2x1| |
                    | |mux|---o2
                a3----|___| |
                    |_______|
                        |
                       Sel-----clock


        3x1 MULTIPLEXER
                   ___
            a0----|2x1|   ___
                  |mux|--|2x1|
            a1----|___|  |mux|
            a2------|----|___|
                    |      |
                    s0     s1

            s0 | s1 | out
            ---|----|----
            0  | 0  | a0
            0  | 1  | a1
            1  | 0  | a2
            1  | 1  | a2


        DEMULTIPLEXER
                         ___
                        |   |---o1
                   i----|   |
                        |___|---o2

------------------------------------------------------------------------------
TIMED CIRCUITS

    Sequential circuits (through time)  Uses a clock.  An oscillator
    that generates equally spaced sequences of 0s and 1s.


        + ----| [] |--- -

             ____      ____      ____
            | 1  |    | 1  |    | 1  |
        ____|    |____|    |____|    |____
         0         0         0         0

        One cycle is called a clock cycle.  The vertical bar represents
    the rise time (the time it takes the oscillator to switch from 0 to
    1.)
        Analog signals (shaped like a sign wave) are filtered to produce
    a step function.  One cycle is called a "tick".  For every tick there
    is an interrupt.  Used in time sharing, time-outs, and hardware use.

        Time diagram for NOT ( ->o )

            0   1   2   3   4   5   6
                ___         ___         1
      in 1         |_______|   |___     0

     out 1          _______     ___     1
                ___|       |___|        0


              ________________
        -----| Combinational  |-----
             |   Circuit      |
         +-->|________________|---+
         |         ___            |
         +--------[___]-----------+
                  feedback
                    mechanism

         We want out(t) = f( in( t-1 ) )

        FLIP-FLOP/LATCH

            S/R latch (the base component of all flip-flops.)

            +----|>o--+------- 0
            |         |
            +------------+
                      |  |      stable state
            +---------+  |
            |            |
            +----|>o-----+---- 1


        FLIP-FLOP WITH ENABLE
                     __             ___
                    |   \          |   \
                +---|AND |---------|OR  }-+------- Q
                |   |___/       +--|___/  |
                |               |         |
            e --|               +---------|-+
                |               +---------+ |
                |    ___        |   ___     |
                |   |   \       +--|   \    |
                +---|AND |---------|OR  }---+----- Q'
                    |___/          |___/


        NEXT-STATE TABLE

            R = 0   S = 0   (G2 = 0 G1 = 1)
            R = 0   S = 1v0 (G2 = 0 G1 = 1)
            R = 0^1 S = 0   (G2 = 1 G1 = 0)
            r = 1   s = 0^1 (G2 = 0 G1 = 0) -- invalid operation/state
                                               (Q1 and Q2 can't be the same.)

            Q, Qn (next state)

                S  | R  | Qn                  S -- set input r -- reset input
                ---|----|--------------
                0  | 0  | no change (Q)
                0  | 1  | 0
                1  | 0  | 1
                1  | 1  | invalid

            Next-state table for flipflop with enable

                e  | in1 | in2 |
                ---|-----|-----|---------
                0  |     |     | Q
                1  | 0   | 0   | Q
                1  | 0   | 1   | 0
                1  | 1   | 0   | 1
                1  | 1   | 1   | invalid

        EXCITATION TABLE

            Given Q, Qn, what are the inputs to flip-flops like this?

                Q  | Qn | S  | R
                ---|----|----|---
                0  | 0  | 0  | x <-- don't care
                0  | 1  | 1  | 0
                1  | 0  | 0  | 1
                1  | 1  | x  | 0

                 ___
            in--|FF |--out
                |_ _|
                  ^
                  clock

        DELAY FLIP-FLOP

            The clock is tied to the enable (refresh as in dynamic RAM)
            To handle invalid inputs,

                            Delay Flip-flop
                                 ___
                        R       |   \
                    +-----------|OR  }o---+--- Q
                    |        +--|___/     |
                    |        |            |
                    o        +----------+ |
                    ^        +----------|-+
                    |        |   ___    |
                D   |   S    +--|   \   |
                ----+-----------|OR  }o-+----- Q'
                                |___/

                D  | Qn
                ---|----
                0  | 0
                1  | 1

                There are also toggle flip-flops and JK flip-flops

        STATE DIAGRAM
            Vertices (states) and edges (transitions).  1 is the input
            0 is the output.
                        0
                 __   _____    ____
                /  \ L     \  L    \
              0|    Q       Q2      | 1
                \__7 \_____7  \____/
                        1

------------------------------------------------------------------------------
SPARC ASSEMBLY

    INSTRUCTIONS

        Syntax:
            opcode src1, src2/immediate, dest

            ex:
                add %l1, %l2, %l3

        Other instructions:
            mov
            add
            sub
            srl
            sll
            sra
            sla
            (sr shift right, sl is shift left.)


    SYNTHETIC INSTRUCTIONS
        mov is a synthetic instruction made of
            add %g0, %l0, %l1
        Where %l0 is the destination, %l1 is the source

        Important synthetic instructions:
            .rem    remainder
            .mul    multiply
            .div    divide


    CONDITION CODES

        Condition codes: n z v c.  'n' is one if the result is negative,
        'z' is one if the result is zero.  'v' is one if there is an
        overflow. Condition codes are only set if you use the cc version
        of opcodes such as addcc.  To compare two values there is a synthetic
        instruction
            cmp %l0, %l1
        Which is composed of
            subcc %l0, %l1, %g0

        There are two ways to change the flow of the instruction: branch
        and jump. (Branch is limited to the same function.)

            ex:
                cmp %l2, 2
                be label         ! also bn, ba, bne
                nop              ! be is synthetic

    FUNCTION CALLS
        To call a function (same for assembly and c)
            1) set the parameters in %o's.
            2) call the function.
            3) return is visible in %o0

            clr <==> add %g0 %g0 %o0

        when returning from function we say
            restore
            return
            nop

        ex:
                .data
            str:    .asciz "%x\n"
                    .text
                    .align 4

                .global main
            main: save %sp, -64, %sp ! reserves 64 bits on the stack
                mov 2, $o0           ! for the registers in the call frame
                mov 3, %o1
                call .mul
                nop

                mov %o0, %a1
                set str, %o1
                call printf
                nop

                clr %o0         ! This line is special for main
                call exit, 0    ! exit returns control back to the
                nop             ! operating system.


    GDB

        disassemble: disass or do it with gcc: gcc -S a1.c -o a1.s
            x/i derefference
            x/x the machine instruction
            x/x $ps


    REGISTER WINDOW

        Register window (the register available to a caller.):

                  | g
                  | o
                -----
                g | l
                o | i
                -----
                l | B
                i |
                -----
                A |

        Register window A and B where A calls B.  When B terminates it
        sends the value over.  The 64 comes from saving register l and
        i (g is shared and o becomes i.)


    CALL GRAPH
            main

              |
              v

              A

              |
              V

              B

    CALL FRAME
        For each function the compiler sets up a call frame in the stack.
        The information that goes in a call frame is the return address
        to the caller.  It contains the storage for local variables.  Also,
        we store the parameters. When it happens that we use to many function
        calls, we put the frame in the stack.  In the entire processor there
        is only one window frame.  So parameters are passed in the stack.

    WINDOW FRAME

                  g is shared throughout
                 /
              | g
              / o --> o becomes i (result returned in %o0)
             /----
          | g | l
          / o-->i
         /--------
        g / l | C
        o-->i |
        -------
        l | B
        i |
        ---
        A |



                  |         |
           sp --> |         |
        1)        | CF_main |
                  |---------|



           sp --> |         |
                  | CF_A    |
                  |---------|
        2)        | CF_main |
                  |---------|



           sp --> |         |
                  | CF_B    |
                  |---------|
                  | CF_A    |
                  |---------|
        3)        | CF_main |
                  |---------|

         * fp points to the bottom of the current call frame.
           sp points to the top of the current call frame.

        The frame pointer points to the bottom of the call frame.  The
        parameters are below it in the calling function.  So a positive
        offset gets them.  The local parameters are accessed with a
        negative offset.


    ACCESSING MEMORY

        SPARC is a load-store architecture.  It loads a register from
        memory (same as fetch.)  store stores the contents of the register
        to the memory.

            load [address] %d  ! load the contents of the memory at
                               ! the location and puts it in d
            store %d [address] ! stores some data in memory

        The load instructions are ldsb, ldub, ldsh, lduh, ld, ldd.
        The store instructions are stb, sth, st, std.  ld and st work
        with words (32 bits.)

            ex: ld [100], %l0 ! load 4 bytes into register from 100
            mov %l1, [100] ! moves those bytes into l1
            addrij = base iJ + j

        You can map a multidimensional raray you can map it in two ways:
        row major and column major.  Row major is mapped something like

            row1 | row2 | row3.

        C derivatives do this.  Fortran is column major:

            col1 | col2 | col3


    STACK FRAME

        Stack frame is composed of the following
            return address
            local variables
            parameters
            frame pointer
            saving registers

        fp + n (parametres)
        fp - n (locals)


        A stack architecture works as follows

            push a           <==>  mov a, %i0
            push b                 mov b, %i1
            call mul               call .mul
                                   nop

    CONTROL FLOW

        Control flow constructs use 2's complement

            if (x & 1)      <==>    ! x is %l0, odd is %l1
                odd = 1;            mov 1, %i1
            else                    and %l0, 1, %l2
                odd = 0;            cmp %l2, 1
                                    bne else
                                    nop
                                    ba nelse
                                    nop
                                    else: mov 0, %l1
                                    nelse:


            int sum(A[n]) {             <==>    clr %l2
                int i = 0, sum = 0;             clr %o0
                while (i < n) {                 loop: cmp %o0, %l1
                    sum += A[i];                be done
                    i++;                        nop
                }                               sll %o0, 2, %o3
                return sum;                     add %l0, %o3, %o3
            }                                   ld [%o3], %o1
                                                add %o1, %l2, %l2
                                                inc %o0
                                                ba loop
                                                nop
                                                done:

    ARRAYS

        Accessing an array
            sll %o0, 2, %o3     ! multiply by 4 (offset)
            add %l0, %o3, %o3   ! o3 is the effective address
            ld [%o3], %o1

ISA

    ISA (instruction set architecture) is made during the design of a
    new processor, or when modifying or updating the current processor.
    Involves arithmetic operations, logic operations, controle flow
    (calling functions), accessing memory, I/O, device access, recursion.
    Return from subroutines.
        ____________
       | High Level |
       |  Language  |
       +------------+
       |    ISA     |
       +------------+
       |  Hardware  |
       |____________|

    MAIN FEATURES

    Main features:
        1) Classification of ISA
            Defined by stack architecture (operands are implied.  Examples:
            HP_UX, calculators, JVM.)
        2) Accumulator register architecture.  There is a register called an
           accumulator which is involved in all operations. (One operand is in
           the accumulator, one is in the operand.)
                c <- a + b    <==>     load a
                                       add b
                                       store c
           Examples include the first processor 80s used in automatic doors and
           such.)
        3) Load and store architecture.
                load r1, [A]
                load r2, [B]
                add r1, r2, r3
                store [C], r3
           Examples include most modern processors.
        4) Memory acces and modes.  The ISA must address how the memory is
           addressed.  Memory is byte addressable or word addressable.  (This
           means that we can only acses words.)  It can be little endian or big
           big-endian.  Effective address -- the base address plus the offset.
           Memory modes: immediate (operand is in the instruction itself.
                ex: mov 2, %l2
           register mode (the operand is in the register.)
                ex: move %l1, %l2
           direct address mode (The memory address is directly in the operand.)
                ex: mov [100], %l3
           register direction (the address is in the register.
                ex: st %l0, [%l1]
           register indirection (address of the address of the operand is in
           the register (this is not supported in SPARC.)  To implement this we
           would
                mov 500, %l0
                ld [%l0], %l1
           reladive offset mode (uses effective addressing.)  The address is
           relative to some value.)  Relative to the program counter pc.  This is
           how branching and jumping work.  In the case of labels the address
           must by 24-bit 2's complement, so you can jump +/- 2^23.  since
           addresses are byte addressable, this is reduced to +/- 2^21 so it is
           pc +/- 2^21.

           load-point -- the start of a chunck of allocated memory.  So when a
           program is loaded it is loaded with the first instruction at the
           load point.  So compilers produce position independent code.
           (PIC)  This is code relative to the pc.

           index mode is relative mode where one register is the index register
           and addressing is relative to the contents of the indexregister.  This
           helpsfor accessing arrays.
                ex: load [%l0 + n], %l1 ! Where l0 is the index register
           Sparc does not have this.
           Autoincrement/autodecrement  this is the origin of ++. (Which now
           simulates autoincrement/autodecrement.)

    ADDRESSING MODES

        ISA addressing modes: immediate, direct address register
        register indirect) indirect relative indexed autoincrement,
        autodecrement.

        ex: 2 byte instruction size memory half-word adressable

        Type            Abbr    Contents
        Program counter pc      200
        Register        R1      400
        Index register  xR      100
        Accumulator     AC

        Memory:
            Address     Contents
            +------+------------------+
            | 200  |  load AC         |
            +------+------------------+
            | 201  |  500             |
            +------+------------------+
            | 202  |                  |
            +------+------------------+
            | ...  |                  |
            +------+------------------+
            | 399  |  450             |
            +------+------------------+
            | 400  |  700             |
            +------+------------------+
            | ...  |                  |
            +------+------------------+
            | 500  |  800             |
            +------+------------------+
            | ...  |                  |
            +------+------------------+
            | 600  |  900             |
            +------+------------------+
            | ...  |                  |
            +------+------------------+
            | 702  |  325             |
            +------+------------------+
            | ...  |                  |
            +------+------------------+
            | 800  |  300             |
            +------+------------------+


        Mode                AC      Effective Address
        direct address      800
        indirect address    300
        relative (pc)       325     EA = 500->202->702
        register            700
        index               900
        register indirect   700     EA = 400 (R1)
        immediate           500

        SPARC IMPLEMENTATION

    Sparc implementation.

        Immediate -- There is a size limitation of 13 bit two's complement
        (-4096 to 4095)
            mov 2, %l0
        Register
            mov %l0, %l1
        Relative (pc) -- The offset is 24-bit 2's complement, actually +/- 2^19
        because of the size of instructions and the sign byte.   This limits the
        size of a module to 8MB.
            ba iloop
            nop
        Indirect does not exist (we can simulate.)
        Direct addressing
            ld [100], %l1
        Indexed We can not do [%l0 + %l1] because it may be larger than 32 bits.
        This is how parameters are based is the call frame
            ld [%i0 + 100], %l1

        A -> B -> C ==> |       |                   ^   -
                        +-------+                   |
                        |  CF B |                   |
                        +-------+ <-- %fp           | lower
                        |  p B  | <-- %fp + 4       | addresses
                        +-------+                   |
                        |  CF A |                   |
                        +-------+                   |   +
        We need to use the frame pointer because the stack pointer is moving.
        A positive offset allows you to go to the previous call fram and the
        parameters.  Negative offsets allow you to go into the current call
        frame.  (No future.)

    Other ISA operations: arithmetic logical flow control transfer
    (branch call and return)  System call interface.

    SYSTEM CALLS
          ____________
         /Applications\
        /  __________  \
       /  / OS Kernel\  \
      /  /    ____    \  \
     /  /_   /    \   _\  \
    |   __  |  HW  |  __   |
     \  \    \____/    /  /
      \  \            /  /
       \  \___| |____/  /
        \              /
         \____________/

        the open gaps in the above representation are called "traps".
        They are implemented as system calls, and allow applications
        to access the underlying hardware.

        In sparc you use a trap instruction, ta 0.  In the original unix
        there were 200 system calls.  In linux there are 600 system calls.
        In Windows there are close to 10,000 system calls.  System calls
        are possible back doors.  System calls are stored in a system call
        table.

            To exit:
                clr %o0
                call exit, 0 ! actualy doing a ta 0
                nop

        Reading one byte at a time takes the same amount of overhead as
        reading 2048 bytes, say, from the system.  So we generally do
        buffered IO, because it is more effective.

    OPERAND ENCODING

        ISA count of operands.  Instruction format.  Options are fixed
        size (SPARC and most risk processors), variable sized instructions
        (have gone out of fashion sometimes known as mixed or hybrid.)
        Classes of different instruction sizes (byte word, double word,
        etc.) (This is technicaly known as fixed size within classes.)
        ISA symcode or instruction.
